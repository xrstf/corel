{
// SPDX-FileCopyrightText: 2023 Christoph Mewes
// SPDX-License-Identifier: MIT

package parser

import "go.xrstf.de/otto/pkg/lang/ast"
}

Program <- __ expr:NonTupleExpression __ EOF {
   return ast.Program{
      Expression: expr.(ast.Expression),
   }, nil
} / stmts:(__ Statement)* __ EOF {
   p := ast.Program{}

   stmtsSl := toAnySlice(stmts)
   if len(stmtsSl) == 0 {
      return p, nil
   }

   for _, stmt := range stmtsSl {
      subSl := toAnySlice(stmt)
      if s, ok := subSl[1].(ast.Statement); ok {
         p.Statements = append(p.Statements, s)
      }
   }

   return p, nil
}

// Statement is basically an alias, but allows for easier top-level detection during execution
Statement <- tup:Tuple {
   return ast.Statement{Tuple: tup.(ast.Tuple)}, nil
}

Expression <- ComplexExpression / ScalarExpression
NonTupleExpression <- Vector / Object / Number / String / Null / Bool / Symbol / Identifier

// ComplexExpression are expressions that are 100% not scalars.
ComplexExpression <- Vector / Object

// ScalarExpression are expressions that have a _chance_ to turn into a scalar.
ScalarExpression <- Number / String / Null / Bool / Tuple / Symbol / Identifier

Tuple <- '(' __ expr:Expression exprs:(___ Expression)* __ ')' {
   t := ast.Tuple{
      Expressions: []ast.Expression{expr.(ast.Expression)},
   }

   exprsSl := toAnySlice(exprs)
   if len(exprsSl) == 0 {
      return t, nil
   }

   for _, expr := range exprsSl {
      subSl := toAnySlice(expr)
      t.Expressions = append(t.Expressions, subSl[1].(ast.Expression))
   }

   return t, nil
}

VectorItemSeparator <- (__ ',' __) / ___

Vector <- '[' __ expr:Expression exprs:( VectorItemSeparator Expression )* __ ']' {
   vector := ast.VectorNode{
      Expressions: []ast.Expression{expr.(ast.Expression)},
   }

   exprsSl := toAnySlice(exprs)
   if len(exprsSl) == 0 {
      return vector, nil
   }

   for _, v := range exprsSl {
      vSl := toAnySlice(v)

      if len(vSl) > 1 {
         vector.Expressions = append(vector.Expressions, vSl[1].(ast.Expression))
      }
   }

   return vector, nil
} / '[' __ ']' {
   return ast.VectorNode{}, nil
}

Object <- '{' pairs:(__ KeyValuePair)* __ '}' {
   o := ast.ObjectNode{}

   pairsSl := toAnySlice(pairs)
   if len(pairsSl) == 0 {
      return o, nil
   }

   for _, pair := range pairsSl {
      pairSl := toAnySlice(pair)
      o.Data = append(o.Data, pairSl[1].(ast.KeyValuePair))
   }

   return o, nil
}

KeyValuePair <- (key:ScalarExpression __ value:Expression) {
   return ast.KeyValuePair{
      Key: key.(ast.Expression),
      Value: value.(ast.Expression),
   }, nil
}

//////////////////////////////////////////////////////////
// path expressions

/*
possible symbols:

   (each step is evaluated immediately, so foo.bar[0] is (foo.bar)[0], not foo.(bar[0]))

// regular identifier
identifier

// regular variable
$var

// traverse variable
$var.subkey
$var[0]
$var[$var]
$var[(add $var 1)]

// deeper traversal
$var.subkey[0].$othervar.subkey

// instead of traversing starting with a var, you can also
// start traversing the current object
.subkey
.subkey[$index].subsubkey.$varstep

// array acces on the global document; this needs a leading dot to distinguish
// it from a bare "[index]", which constructs an array with 1 element in it
.[index]

*/

Symbol <- '.' acc:ArrayAccessor expr:QualifiedPathExpression? {
   arrAcc := acc.(ast.Expression)

   pathExpr := ast.PathExpression{}
   if expr != nil {
      pathExpr = expr.(ast.PathExpression)
   }

   pathExpr.Prepend(arrAcc)

   return ast.Symbol{PathExpression: &pathExpr}, nil
} / acc:ObjectAccessor expr:QualifiedPathExpression? {
   objAcc := acc.(ast.Expression)

   pathExpr := ast.PathExpression{}
   if expr != nil {
      pathExpr = expr.(ast.PathExpression)
   }

   pathExpr.Prepend(objAcc)

   return ast.Symbol{PathExpression: &pathExpr}, nil
} / val:Variable expr:QualifiedPathExpression? {
   variable := val.(ast.Variable)

   var pathExpr *ast.PathExpression
   if expr != nil {
      asserted := expr.(ast.PathExpression)
      pathExpr = &asserted
   }

   return ast.Symbol{
      Variable: &variable,
      PathExpression: pathExpr,
   }, nil
} / '.' {
   return ast.Symbol{
      PathExpression: &ast.PathExpression{},
   }, nil
}

// QualifiedPathExpression follows any qualifier (currently only variables or another path expression)
QualifiedPathExpression <- pathExpr:(Accessor)+ {
   path := ast.PathExpression{}
   steps := toAnySlice(pathExpr)

   for i := range steps {
      path.Steps = append(path.Steps, steps[i].(ast.Expression))
   }

   return path, nil
}

Accessor <- ObjectAccessor / ArrayAccessor

ObjectAccessor <- '.' val:PathIdentifier {
   return val, nil
}

ArrayAccessor <- '[' expr:ScalarExpression ']' {
   return expr, nil
}

PathIdentifier <- [a-zA-Z_][a-zA-Z0-9_]* {
   return ast.Identifier(string(c.text)), nil
}

//////////////////////////////////////////////////////////
// other symbols

Variable <- '$' name:VariableName {
   return ast.Variable(name.(string)), nil
}

VariableName <- [a-zA-Z_][a-zA-Z0-9_]* {
   return string(c.text), nil
}

Identifier <- [a-zA-Z_+/*_%?-][a-zA-Z0-9_+/*_%?!-]* {
   return ast.Identifier(string(c.text)), nil
}

//////////////////////////////////////////////////////////
// special types

Bool <- "true" { return ast.Bool(true), nil } / "false" { return ast.Bool(false), nil }

Null <- "null" { return ast.Null{}, nil }

//////////////////////////////////////////////////////////
// numbers (ints and floats)

Number <- '-'? Integer (( '.' DecimalDigit+ ) / Exponent) {
   // JSON numbers have the same syntax as Go's, and are parseable using
   // strconv.
   value, err := strconv.ParseFloat(string(c.text), 64)
   if err != nil {
      return nil, err // should never happen
   }

   return ast.Number{Value: value}, nil
} / i:Integer {
   return ast.Number{Value: i}, nil
}

Integer <- '0' {
   return int64(0), nil
} / '-'? NonZeroDecimalDigit DecimalDigit* {
   value, err := strconv.ParseInt(string(c.text), 10, 64)
   if err != nil {
      return nil, err // should never happen
   }

   return value, nil
}

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

Exponent <- 'e'i [+-]? DecimalDigit+

//////////////////////////////////////////////////////////
// strings

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
   c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)

   unquoted, err := strconv.Unquote(string(c.text))
   if err != nil {
      return nil, err
   }

   return ast.String(unquoted), nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape / UnicodeEscape

SingleCharEscape <- ["\\/bfnrt]

UnicodeEscape <- 'u' HexDigit HexDigit HexDigit HexDigit

HexDigit <- [0-9a-f]i

//////////////////////////////////////////////////////////
// comments

SingleLineComment ← "#" ( !EOL . )*

//////////////////////////////////////////////////////////
// misc

___ <- ( Whitespace / EOL / SingleLineComment )+
__ <- ( Whitespace / EOL / SingleLineComment )*
_ <- Whitespace*

Whitespace <- [ \t\r]
EOL <- '\n'
EOS <- _ SingleLineComment? EOL / __ EOF

EOF <- !.
