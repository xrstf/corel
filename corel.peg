{
// SPDX-FileCopyrightText: 2023 Christoph Mewes
// SPDX-License-Identifier: MIT

package parser

import "go.xrstf.de/corel/pkg/lang/ast"
}

Program <- stmts:(__ Statement)* __ EOF {
   p := ast.Program{}

   stmtsSl := toAnySlice(stmts)
   if len(stmtsSl) == 0 {
      return p, nil
   }

   for _, stmt := range stmtsSl {
      subSl := toAnySlice(stmt)
      if s, ok := subSl[1].(ast.Statement); ok {
         p.Statements = append(p.Statements, s)
      }
   }

   return p, nil
}

// Statement is basically an alias, but allows for easier top-level detection during execution
Statement <- expr:Expression {
   fmt.Printf("expr: %q\n", string(c.text))
   return ast.Statement{Expression: expr.(ast.Expression)}, nil
}

Expression <- val:Number {
   data, _ := val.(ast.Number)
   return ast.Expression{NumberNode: &data}, nil
} / val:String {
   data, _ := val.(ast.String)
   return ast.Expression{StringNode: &data}, nil
} / val:Null {
   data, _ := val.(ast.Null)
   return ast.Expression{NullNode: &data}, nil
} / val:Bool {
   data, _ := val.(ast.Bool)
   return ast.Expression{BoolNode: &data}, nil
} / val:Tuple {
   data, _ := val.(ast.Tuple)
   return ast.Expression{TupleNode: &data}, nil
} / val:Vector {
   data, _ := val.(ast.Vector)
   return ast.Expression{VectorNode: &data}, nil
} / val:Object {
   data, _ := val.(ast.Object)
   return ast.Expression{ObjectNode: &data}, nil
} / val:Symbol {
   data, _ := val.(ast.Symbol)
   return ast.Expression{SymbolNode: &data}, nil
}

Tuple <- '(' __ ident:Identifier exprs:(__ Expression)* __ ')' {
   t := ast.Tuple{Identifier: ident.(ast.Identifier)}

   exprsSl := toAnySlice(exprs)
   if len(exprsSl) == 0 {
      return t, nil
   }

   for _, expr := range exprsSl {
      subSl := toAnySlice(expr)
      t.Expressions = append(t.Expressions, subSl[1].(ast.Expression))
   }

   return t, nil
}

Vector <- '[' __ vals:( Expression ( __ ','? __ Expression )* )? __ ']' {
   vector := ast.Vector{}

   valsSl := toAnySlice(vals)
   if len(valsSl) == 0 {
      return vector, nil
   }

   vector.Expressions = append(vector.Expressions, valsSl[0].(ast.Expression))

   restSl := toAnySlice(valsSl[1])
   for _, v := range restSl {
      vSl := toAnySlice(v)
      vector.Expressions = append(vector.Expressions, vSl[3].(ast.Expression))
   }

   return vector, nil
}

Object <- '{' pairs:(__ KeyValuePair)* __ '}' {
   o := ast.Object{}

   pairsSl := toAnySlice(pairs)
   if len(pairsSl) == 0 {
      return o, nil
   }

   for _, pair := range pairsSl {
      pairSl := toAnySlice(pair)
      o.Data = append(o.Data, pairSl[1].(ast.KeyValuePair))
   }

   return o, nil
}

KeyValuePair <- (key:Symbol __ value:Expression) {
   return ast.KeyValuePair{
      Key: key.(ast.Symbol),
      Value: value.(ast.Expression),
   }, nil
}

//////////////////////////////////////////////////////////
// path expressions

/*
possible symbols:

   (each step is evaluated immediately, so foo.bar[0] is (foo.bar)[0], not foo.(bar[0]))

// regular identifier
identifier

// regular variable
$var

// traverse variable
$var.subkey
$var[0]
$var[$var]
$var[(add $var 1)]

// deeper traversal
$var.subkey[0].$othervar.subkey

// instead of traversing starting with a var, you can also
// start traversing the current object
.subkey
.subkey[$index].subsubkey.$varstep

// array acces on the global document; this needs a leading dot to distinguish
// it from a bare "[index]", which constructs an array with 1 element in it
.[index]

*/

Symbol <- '.' acc:ArrayAccessor expr:QualifiedPathExpression* {
   arrAcc, _ := acc.(ast.Accessor)

   pathExpr := ast.PathExpression{}
   if pathExprSl := toAnySlice(expr); pathExprSl != nil {
      pathExpr = pathExprSl[0].(ast.PathExpression)
   }

   pathExpr.Prepend(arrAcc)

   return ast.Symbol{PathExpression: &pathExpr}, nil
} / acc:ObjectAccessor expr:QualifiedPathExpression* {
   objAcc, _ := acc.(ast.Accessor)

   pathExpr := ast.PathExpression{}
   if pathExprSl := toAnySlice(expr); pathExprSl != nil {
      pathExpr = pathExprSl[0].(ast.PathExpression)
   }

   pathExpr.Prepend(objAcc)

   return ast.Symbol{PathExpression: &pathExpr}, nil
} / val:Variable pathExpr:QualifiedPathExpression* {
   var expr *ast.PathExpression
   if pathExprSl := toAnySlice(pathExpr); pathExprSl != nil {
      exp := pathExprSl[0].(ast.PathExpression)
      expr = &exp
   }

   variable, _ := val.(ast.Variable)
   return ast.Symbol{
      Variable: &variable,
      PathExpression: expr,
   }, nil
} / val:Identifier {
   ident, _ := val.(ast.Identifier)
   return ast.Symbol{Identifier: &ident}, nil
}

// QualifiedPathExpression follows any qualifier (currently only variables or another path expression)
QualifiedPathExpression <- pathExpr:(Accessor)+ {
   path := ast.PathExpression{}
   steps := toAnySlice(pathExpr)

   for i := range steps {
      path.Steps = append(path.Steps, steps[i].(ast.Accessor))
   }

   return path, nil
}

Accessor <- ObjectAccessor / ArrayAccessor

ObjectAccessor <- '.' val:PathIdentifier {
   asserted := val.(ast.Identifier)
   return ast.Accessor{Identifier: &asserted}, nil
} / '.' val:Variable {
   asserted := val.(ast.Variable)
   return ast.Accessor{Variable: &asserted}, nil
}

ArrayAccessor <- '[' val:String ']' {
   asserted := val.(ast.String)
   return ast.Accessor{StringNode: &asserted}, nil
} / '[' val:Variable ']' {
   asserted := val.(ast.Variable)
   return ast.Accessor{Variable: &asserted}, nil
} / '[' val:Tuple ']' {
   asserted := val.(ast.Tuple)
   return ast.Accessor{Tuple: &asserted}, nil
} / '[' val:Integer ']' {
   asserted := val.(int64)
   return ast.Accessor{Integer: &asserted}, nil
}

PathIdentifier <- [a-zA-Z_][a-zA-Z0-9_]* {
   return ast.Identifier{Name: string(c.text)}, nil
}

//////////////////////////////////////////////////////////
// other symbols

Variable <- '$' name:VariableName {
   return ast.Variable{Name: name.(string)}, nil
}

VariableName <- [a-zA-Z_][a-zA-Z0-9_]* {
   return string(c.text), nil
}

Identifier <- [a-zA-Z_+/*_%?-][a-zA-Z0-9_+/*_%?-]* {
   return ast.Identifier{Name: string(c.text)}, nil
}

//////////////////////////////////////////////////////////
// special types

Bool <- "true" { return ast.Bool{Value: true}, nil } / "false" { return ast.Bool{Value: false}, nil }

Null <- "null" { return ast.Null{}, nil }

//////////////////////////////////////////////////////////
// numbers (ints and floats)

Number <- '-'? Integer (( '.' DecimalDigit+ ) / Exponent) {
   // JSON numbers have the same syntax as Go's, and are parseable using
   // strconv.
   value, err := strconv.ParseFloat(string(c.text), 64)
   if err != nil {
      return nil, err // should never happen
   }

   return ast.Number{Value: value}, nil
} / i:Integer {
   return ast.Number{Value: i}, nil
}

Integer <- '0' {
   return int64(0), nil
} / '-'? NonZeroDecimalDigit DecimalDigit* {
   value, err := strconv.ParseInt(string(c.text), 10, 64)
   if err != nil {
      return nil, err // should never happen
   }

   return value, nil
}

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

Exponent <- 'e'i [+-]? DecimalDigit+

//////////////////////////////////////////////////////////
// strings

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
   c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)

   unquoted, err := strconv.Unquote(string(c.text))
   if err != nil {
      return nil, err
   }

   return ast.String{Value: unquoted}, nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape / UnicodeEscape

SingleCharEscape <- ["\\/bfnrt]

UnicodeEscape <- 'u' HexDigit HexDigit HexDigit HexDigit

HexDigit <- [0-9a-f]i

//////////////////////////////////////////////////////////
// comments

SingleLineComment ← "#" ( !EOL . )* {
   fmt.Printf("SingleLineComment: %q\n", string(c.text))
   return nil, nil
}

//////////////////////////////////////////////////////////
// misc

__ <- ( Whitespace / EOL / SingleLineComment )*
_ <- Whitespace*

Whitespace <- [ \t\r]
EOL <- '\n'
EOS <- _ SingleLineComment? EOL / __ EOF

EOF <- !.
