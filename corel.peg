{
package parser

import "go.xrstf.de/corel/pkg/lang/ast"
}

Program <- exprs:(_ Expression)* _ EOF {
   p := ast.Program{}

   exprsSl := toAnySlice(exprs)
   if len(exprsSl) == 0 {
      return p, nil
   }

   for _, expr := range exprsSl {
      subSl := toAnySlice(expr)
      p.Expressions = append(p.Expressions, subSl[1].(ast.Expression))
   }

   return p, nil
}

Expression <- val:Number {
   data, _ := val.(ast.Number)
   return ast.Expression{NumberNode: &data}, nil
} / val:String {
   data, _ := val.(ast.String)
   return ast.Expression{StringNode: &data}, nil
} / val:Null {
   data, _ := val.(ast.Null)
   return ast.Expression{NullNode: &data}, nil
} / val:Bool {
   data, _ := val.(ast.Bool)
   return ast.Expression{BoolNode: &data}, nil
} / val:Tuple {
   data, _ := val.(ast.Tuple)
   return ast.Expression{TupleNode: &data}, nil
} / val:Vector {
   data, _ := val.(ast.Vector)
   return ast.Expression{VectorNode: &data}, nil
} / val:Object {
   data, _ := val.(ast.Object)
   return ast.Expression{ObjectNode: &data}, nil
} / val:Symbol {
   data, _ := val.(ast.Symbol)
   return ast.Expression{SymbolNode: &data}, nil
}

Tuple <- '(' _ sym:Symbol exprs:(_ Expression)* _ ')' {
   t := ast.Tuple{Symbol: sym.(ast.Symbol)}

   exprsSl := toAnySlice(exprs)
   if len(exprsSl) == 0 {
      return t, nil
   }

   for _, expr := range exprsSl {
      subSl := toAnySlice(expr)
      t.Expressions = append(t.Expressions, subSl[1].(ast.Expression))
   }

   return t, nil
}

Vector <- '[' _ vals:( Expression ( ','? _ Expression )* )? ']' {
   vector := ast.Vector{}

   valsSl := toAnySlice(vals)
   if len(valsSl) == 0 {
      return vector, nil
   }

   vector.Expressions = append(vector.Expressions, valsSl[0].(ast.Expression))

   restSl := toAnySlice(valsSl[1])
   for _, v := range restSl {
      vSl := toAnySlice(v)
      vector.Expressions = append(vector.Expressions, vSl[2].(ast.Expression))
   }

   return vector, nil
}

Object <- '{' pairs:(_ KeyValuePair)* _ '}' {
   o := ast.Object{}

   pairsSl := toAnySlice(pairs)
   if len(pairsSl) == 0 {
      return o, nil
   }

   for _, pair := range pairsSl {
      pairSl := toAnySlice(pair)
      o.Data = append(o.Data, pairSl[1].(ast.KeyValuePair))
   }

   return o, nil
}

KeyValuePair <- (key:Symbol _ value:Expression) {
   return ast.KeyValuePair{
      Key: key.(ast.Symbol),
      Value: value.(ast.Expression),
   }, nil
}

Symbol <- val:JSONPath {
   jsonPath, _ := val.(ast.JSONPath)
   return ast.Symbol{JSONPath: &jsonPath}, nil
} / val:Variable {
   variable, _ := val.(ast.Variable)
   return ast.Symbol{Variable: &variable}, nil
} / val:Identifier {
   ident, _ := val.(ast.Identifier)
   return ast.Symbol{Identifier: &ident}, nil
}

JSONPath <- vals:('.' JSONPathStep)+ {
   path := ast.JSONPath{}
   for _, val := range toAnySlice(vals) {
      list := val.([]interface{})
      path = append(path, list[1].(string))
   }

   return path, nil
}

JSONPathStep <- [a-zA-Z0-9_]+ {
   return string(c.text), nil
}

Variable <- '$' name:VariableName {
   return ast.Variable{Name: name.(string)}, nil
}

VariableName <- [a-zA-Z0-9_]+ {
   return string(c.text), nil
}

Identifier <- [a-zA-Z0-9_]+ {
   return ast.Identifier{Name: string(c.text)}, nil
}

//////////////////////////////////////////////////////////
// special types

Bool <- "true" { return ast.Bool{Value: true}, nil } / "false" { return ast.Bool{Value: false}, nil }

Null <- "null" { return ast.Null{}, nil }

//////////////////////////////////////////////////////////
// numbers (ints and floats)

Number <- '-'? Integer ( '.' DecimalDigit+ )? Exponent? {
    // JSON numbers have the same syntax as Go's, and are parseable using
    // strconv.
    value, err := strconv.ParseFloat(string(c.text), 64)
    if err != nil {
      return nil, err // should never happen
    }

    return ast.Number{Value: value}, nil
}

Integer <- '0' / NonZeroDecimalDigit DecimalDigit*

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

Exponent <- 'e'i [+-]? DecimalDigit+

//////////////////////////////////////////////////////////
// strings

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)

    unquoted, err := strconv.Unquote(string(c.text))
    if err != nil {
      return nil, err
    }

    return ast.String{Value: unquoted}, nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape / UnicodeEscape

SingleCharEscape <- ["\\/bfnrt]

UnicodeEscape <- 'u' HexDigit HexDigit HexDigit HexDigit

HexDigit <- [0-9a-f]i

//////////////////////////////////////////////////////////
// misc

_ "whitespace" <- [ \t\r\n]*

EOF <- !.
