{
// Package lang parses COREL programs.
package lang

func toAnySlice(v any) []any {
    if v == nil {
        return nil
    }
    return v.([]any)
}

}

Program <- exprs:(_ Expression)* _ EOF {
   p := Program{}

   exprsSl := toAnySlice(exprs)
   if len(exprsSl) == 0 {
      return p, nil
   }

   for _, expr := range exprsSl {
      subSl := toAnySlice(expr)
      p.Expressions = append(p.Expressions, subSl[1].(Expression))
   }

   return p, nil
}

Expression <- val:Number {
   data, _ := val.(Number)
   return Expression{NumberNode: &data}, nil
} / val:String {
   data, _ := val.(String)
   return Expression{StringNode: &data}, nil
} / val:Null {
   data, _ := val.(Null)
   return Expression{NullNode: &data}, nil
} / val:Bool {
   data, _ := val.(Bool)
   return Expression{BoolNode: &data}, nil
} / val:Tuple {
   data, _ := val.(Tuple)
   return Expression{TupleNode: &data}, nil
} / val:Vector {
   data, _ := val.(Vector)
   return Expression{VectorNode: &data}, nil
} / val:Object {
   data, _ := val.(Object)
   return Expression{ObjectNode: &data}, nil
} / val:Symbol {
   data, _ := val.(Symbol)
   return Expression{SymbolNode: &data}, nil
}

Tuple <- '(' _ sym:Symbol exprs:(_ Expression)* _ ')' {
   t := Tuple{Symbol: sym.(Symbol)}

   exprsSl := toAnySlice(exprs)
   if len(exprsSl) == 0 {
      return t, nil
   }

   for _, expr := range exprsSl {
      subSl := toAnySlice(expr)
      t.Expressions = append(t.Expressions, subSl[1].(Expression))
   }

   return t, nil
}

Vector <- '[' _ vals:( Expression ( ','? _ Expression )* )? ']' {
   valsSl := toAnySlice(vals)
   if len(valsSl) == 0 {
      return Vector{}, nil
   }

   vector := Vector{}
   vector.Expressions = append(vector.Expressions, valsSl[0].(Expression))

   restSl := toAnySlice(valsSl[1])
   for _, v := range restSl {
      vSl := toAnySlice(v)
      vector.Expressions = append(vector.Expressions, vSl[2].(Expression))
   }

   return vector, nil
}

Object <- '{' pairs:(_ KeyValuePair)* _ '}' {
   o := Object{}

   pairsSl := toAnySlice(pairs)
   if len(pairsSl) == 0 {
      return o, nil
   }

   for _, pair := range pairsSl {
      pairSl := toAnySlice(pair)
      o.Data = append(o.Data, pairSl[1].(KeyValuePair))
   }

   return o, nil
}

KeyValuePair <- (key:Symbol _ value:Expression) {
   return KeyValuePair{
      Key: key.(Symbol),
      Value: value.(Expression),
   }, nil
}

Symbol <- val:JSONPath {
   jsonPath, _ := val.(JSONPath)
   return Symbol{JSONPath: &jsonPath}, nil
} / val:Variable {
   variable, _ := val.(Variable)
   return Symbol{Variable: &variable}, nil
} / val:Identifier {
   ident, _ := val.(Identifier)
   return Symbol{Identifier: &ident}, nil
}

JSONPath <- vals:('.' JSONPathStep)+ {
   path := JSONPath{}
   for _, val := range toAnySlice(vals) {
      list := val.([]interface{})
      path = append(path, list[1].(string))
   }

   return path, nil
}

JSONPathStep <- [a-zA-Z0-9_]+ {
   return string(c.text), nil
}

Variable <- '$' name:VariableName {
   return Variable{Name: name.(string)}, nil
}

VariableName <- [a-zA-Z0-9_]+ {
   return string(c.text), nil
}

Identifier <- [a-zA-Z0-9_]+ {
   return Identifier{Name: string(c.text)}, nil
}

//////////////////////////////////////////////////////////
// special types

Bool <- "true" { return Bool{Value: true}, nil } / "false" { return Bool{Value: false}, nil }

Null <- "null" { return Null{}, nil }

//////////////////////////////////////////////////////////
// numbers (ints and floats)

Number <- '-'? Integer ( '.' DecimalDigit+ )? Exponent? {
    // JSON numbers have the same syntax as Go's, and are parseable using
    // strconv.
    value, err := strconv.ParseFloat(string(c.text), 64)
    if err != nil {
      return nil, err // should never happen
    }

    return Number{Value: value}, nil
}

Integer <- '0' / NonZeroDecimalDigit DecimalDigit*

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

Exponent <- 'e'i [+-]? DecimalDigit+

//////////////////////////////////////////////////////////
// strings

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)

    unquoted, err := strconv.Unquote(string(c.text))
    if err != nil {
      return nil, err
    }

    return String{Value: unquoted}, nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape / UnicodeEscape

SingleCharEscape <- ["\\/bfnrt]

UnicodeEscape <- 'u' HexDigit HexDigit HexDigit HexDigit

HexDigit <- [0-9a-f]i

//////////////////////////////////////////////////////////
// misc

_ "whitespace" <- [ \t\r\n]*

EOF <- !.
